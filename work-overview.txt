1)Чи допрацювали ви контейнери попереднього тижня?

Так отримавши деякі зауваження та пропозиціїї щодо моїх структур даних постарався допрацювати 
їх та десь додати методи десь прибрати непотрібні і оптимізувати роботу, 
наприклад: arraylist зробивши створення масиву для зберігання спочатку більшим і потім при ресайзі 
ресайзити при потребі не на 1 одиницю розміру а в 2 рази.

2)З якими труднощами зіткнулися при перекладі своїх проектів на свої колекції?

Великих труднощів при переведенні не було, переведення джавовських контейнерів на власні зайняло в мене не дуже багато часу але попередньо довго
довелося працювати зі своїми контейнерами досить важко та довго.

3)Наскільки просіла продуктивність від переходу?

Швидкість роботи калькулятора та знаходжувача силуетів не змінилася.
Після переробки HashMap на роботу з силками продуктивність роботи архіватора стала така як і на джавовських контейнерах, 
навіть іноді працює швидше.

4)Яким алгоритмом реалізували PriorityQueue?

Переробив алгоритм роботи priority queue, тепер я використовую бінарну кучу. Бінарна куча це можна сказати дерево, яке на диво
дуже легко представити у вигляді одномірного масиву, це можна зробити так: Елемент з індексом i має синів з такими індексами 2 * і + 1 та
2 * і + 2, тобто якщо елемент з індексом 0 то його сини це елементи з індексами 1 та 2 і т.д. 
Також за допомогою бінарної кучі можна легко змінювати елементи місцями, для цього я використовую два методи: siftUp та siftDown перший метод
використовується коли ми додаємо новий елемент до черги другий коли видаляємо елемент з черги.
Метод siftUp працює так що він порівнює введений елемент з батьком якщо цей елемент менший за пріоритетом ніж його батько тоді 
він змінюється з ним місцям, якщо ж ні тоді цикл припиняє свою роботу і все залишається на своїх місцях
Метод siftDown працює так що при видалені елементу з черги на місце цього елементу ми ставимо останній елемент і викликаємо цей метод, 
який в свою чергу визначає найменшого сина і зрівнює цей елемент з наймешним сином якщо син за пріоритетом менший тоді син свапається з батьком,
доки порядок не буде встановлений. 



5)Як ви боретеся з колізіями в HashMap?

Для того щоб працювати с колізіями створив для роботи з hash map клас який 
представляє собою односторонній вузол тільки з посиланням на ще один такий вузол який має назву HashNode. 
Тобто якщо в мене два і більше елементи з однаковим індексом то я просто беру елемент який вже маю з таким індексом
і створюю посилання від нього на другий елемент з таким же індексом.

6)Чи тягне ваша робота на 5?

Вважаю що ні, так як, я не зробив ітератори для кожного контейнеру, та можливо в коді є ще деякісь недорахунки та баги. 